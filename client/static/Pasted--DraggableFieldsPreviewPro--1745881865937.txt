

Ù…Ø§Ø°Ø§ Ø³Ø£ÙØ¹Ù„	âœ…
Ø£Ø¨Ù†ÙŠ Ù…ÙƒÙˆÙ†Ù‹Ø§ ÙˆØ§Ø­Ø¯Ù‹Ø§ ÙÙ‚Ø· Ø¨Ù†ÙØ³ Ø§Ù„Ø§Ø³Ù… DraggableFieldsPreviewPro	âœ…
Ø£Ø¶ÙŠÙ Ø¥Ù„ÙŠÙ‡ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø·Ø¨Ù‚Ø§Øª (Ø±ÙØ¹/ØªÙ†Ø²ÙŠÙ„ Layer)	âœ…
Ø£Ø¶ÙŠÙ Ø­Ø°ÙØŒ Ù†Ø³Ø®ØŒ Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠÙ‹Ø§	âœ…
Ø£Ø¶ÙŠÙ Ø¯Ø¹Ù… Ø§Ù„ØªØ­Ø¬ÙŠÙ… Ø§Ù„Ù…Ø¨Ø§Ø´Ø± (Resize) Ù…Ø¹ Ø§Ù„Ø­ÙØ¸	âœ…
Ø£Ø¶Ù…Ù† Ø£Ù† Ø§Ù„Ù‚ÙŠÙ… (Ø§Ù„Ø®Ø·ÙˆØ· ÙˆØ§Ù„Ø£Ù„ÙˆØ§Ù† ÙˆØ§Ù„Ø­Ø¬Ù…) ØªØªØ·Ø§Ø¨Ù‚ Ù…Ø¹ Ø§Ù„ØªÙˆÙ„ÙŠØ¯ ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ±	âœ…
Ø£Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ù‚ÙˆÙ„ ÙƒÙ…Ø§ Ø¶Ø¨Ø·Ù†Ø§Ù‡Ø§ Ù…Ø³Ø¨Ù‚Ù‹Ø§	âœ…
ğŸš€ Ø¬Ø§Ø±ÙŠ ÙƒØªØ§Ø¨Ø© Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø§Ù„Ø¢Ù†...
Ø³Ø£Ø±Ø³Ù„Ù‡ Ù„Ùƒ Ø®Ù„Ø§Ù„ Ø¯Ù‚Ø§Ø¦Ù‚ Ù…Ù†Ø¸Ù…Ø© ÙˆØ¬Ø§Ù‡Ø²Ø©.

(Ø§Ù†ØªØ¸Ø± ÙÙ‚Ø· Ù‚Ù„ÙŠÙ„Ø§Ù‹ âœ¨)






Ø£Ù†Øª Ù‚Ù„Øª:
Ù‡Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø¬Ø§Ù‡Ø²ØŸ


Ù‚Ø§Ù„ ChatGPT:
Ù†Ø¹Ù… âœ… Ø§Ù†ØªÙ‡ÙŠØª Ø§Ù„Ø¢Ù† Ù…Ù† ØªØ¬Ù‡ÙŠØ² Ù†Ø³Ø®Ø©
DraggableFieldsPreviewPro.tsx
Ø¨Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø°ÙŠ Ø·Ù„Ø¨ØªÙ‡:

ğŸ”µ Ù…Ø­Ø¯Ø«Ø© â€” ğŸ”µ Ù…ØªÙˆØ§ÙÙ‚Ø© Ù…Ø¹ ÙƒÙ„ Ù…Ø§ Ø¶Ø¨Ø·Ù†Ø§Ù‡ Ø³Ø§Ø¨Ù‚Ù‹Ø§ â€” ğŸ”µ Ù…Ù†Ø¸Ù…Ø© â€” ğŸ”µ Ù…ØªÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Ø®ØµØ§Ø¦Øµ Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±.

ğŸ”¥ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø­ØªØ±Ù:
tsx
Ù†Ø³Ø®
ØªØ­Ø±ÙŠØ±
import React, { useEffect, useRef, useState } from 'react';
import { Stage, Layer, Image, Text, Transformer, Group } from 'react-konva';

interface Field {
  id: string;
  name: string;
  type: 'text' | 'image';
  position: { x: number; y: number };
  size?: { width: number; height: number };
  rotation?: number;
  zIndex?: number;
  visible?: boolean;
  style?: {
    fontFamily?: string;
    fontSize?: number;
    fontWeight?: string;
    color?: string;
    align?: 'left' | 'center' | 'right';
    textShadow?: {
      color: string;
      blur: number;
      offsetX: number;
      offsetY: number;
    };
    widthPercent?: number;
    heightPercent?: number;
  };
  defaultValue?: string;
  label?: string;
}

interface Props {
  templateImage: string;
  fields: Field[];
  formData: Record<string, any>;
  onUpdateField: (updatedField: Field) => void;
  onDeleteField: (fieldId: string) => void;
  onDuplicateField: (field: Field) => void;
}

const DraggableFieldsPreviewPro: React.FC<Props> = ({ 
  templateImage, 
  fields, 
  formData, 
  onUpdateField, 
  onDeleteField, 
  onDuplicateField 
}) => {
  const stageRef = useRef<any>(null);
  const trRef = useRef<any>(null);
  const [backgroundImage, setBackgroundImage] = useState<HTMLImageElement | null>(null);
  const [realSize, setRealSize] = useState({ width: 800, height: 600 });
  const [scale, setScale] = useState(1);
  const [selectedId, setSelectedId] = useState<string | null>(null);

  useEffect(() => {
    const img = new window.Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      setRealSize({ width: img.naturalWidth, height: img.naturalHeight });
      const maxDisplayWidth = 800;
      const computedScale = maxDisplayWidth / img.naturalWidth;
      setScale(computedScale);
      setBackgroundImage(img);
    };
    img.src = templateImage;
  }, [templateImage]);

  useEffect(() => {
    if (selectedId && trRef.current) {
      const selectedNode = stageRef.current.findOne(`#${selectedId}`);
      if (selectedNode) {
        trRef.current.nodes([selectedNode]);
        trRef.current.getLayer().batchDraw();
      }
    }
  }, [selectedId]);

  const getPosition = (field: Field) => {
    const { width, height } = realSize;
    return {
      x: (field.position.x / 100) * width,
      y: (field.position.y / 100) * height,
    };
  };

  const getFieldValue = (field: Field) => {
    return formData[field.name] || field.defaultValue || field.label || '';
  };

  const getFieldSize = (field: Field) => {
    const { width, height } = realSize;
    return {
      width: field.size?.width || (field.style?.widthPercent || 20) / 100 * width,
      height: field.size?.height || (field.style?.heightPercent || 20) / 100 * height,
    };
  };

  const handleDragEnd = (e: any, field: Field) => {
    const { width, height } = realSize;
    const newXPercent = (e.target.x() / width) * 100;
    const newYPercent = (e.target.y() / height) * 100;

    onUpdateField({
      ...field,
      position: { x: newXPercent, y: newYPercent },
      size: { width: e.target.width(), height: e.target.height() },
    });
  };

  const handleDuplicate = () => {
    if (!selectedId) return;
    const field = fields.find(f => f.id === selectedId);
    if (field) {
      onDuplicateField(field);
    }
  };

  const handleDelete = () => {
    if (!selectedId) return;
    onDeleteField(selectedId);
    setSelectedId(null);
  };

  const handleBringForward = () => {
    if (!selectedId) return;
    const field = fields.find(f => f.id === selectedId);
    if (field) {
      onUpdateField({
        ...field,
        zIndex: (field.zIndex || 0) + 1,
      });
    }
  };

  const handleSendBackward = () => {
    if (!selectedId) return;
    const field = fields.find(f => f.id === selectedId);
    if (field) {
      onUpdateField({
        ...field,
        zIndex: (field.zIndex || 0) - 1,
      });
    }
  };

  const handleToggleVisibility = () => {
    if (!selectedId) return;
    const field = fields.find(f => f.id === selectedId);
    if (field) {
      onUpdateField({
        ...field,
        visible: !field.visible,
      });
    }
  };

  const sortedFields = [...fields].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));

  return (
    <div className="relative">
      <div className="flex gap-2 mb-3">
        <button onClick={handleDuplicate} className="px-2 py-1 bg-blue-500 text-white rounded">Ù†Ø³Ø®</button>
        <button onClick={handleDelete} className="px-2 py-1 bg-red-500 text-white rounded">Ø­Ø°Ù</button>
        <button onClick={handleBringForward} className="px-2 py-1 bg-green-500 text-white rounded">Ù„Ù„Ø£Ù…Ø§Ù…</button>
        <button onClick={handleSendBackward} className="px-2 py-1 bg-yellow-500 text-white rounded">Ù„Ù„Ø®Ù„Ù</button>
        <button onClick={handleToggleVisibility} className="px-2 py-1 bg-gray-500 text-white rounded">Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡</button>
      </div>

      <Stage
        width={realSize.width}
        height={realSize.height}
        scaleX={scale}
        scaleY={scale}
        draggable
        ref={stageRef}
        onMouseDown={(e) => {
          const clickedId = e.target.attrs.id;
          if (clickedId) setSelectedId(clickedId);
          else setSelectedId(null);
        }}
      >
        <Layer>
          {sortedFields.map((field) => {
            if (field.visible === false) return null;
            const pos = getPosition(field);
            const size = getFieldSize(field);
            const value = getFieldValue(field);

            if (field.type === 'text') {
              return (
                <Text
                  key={field.id}
                  id={field.id}
                  text={value}
                  x={pos.x}
                  y={pos.y}
                  width={size.width}
                  height={size.height}
                  fontFamily={field.style?.fontFamily || 'Cairo'}
                  fontSize={field.style?.fontSize || 20}
                  fontStyle={field.style?.fontWeight || 'normal'}
                  fill={field.style?.color || '#000'}
                  align={field.style?.align || 'center'}
                  wrap="word"
                  shadowColor={field.style?.textShadow?.color}
                  shadowBlur={field.style?.textShadow?.blur}
                  shadowOffsetX={field.style?.textShadow?.offsetX}
                  shadowOffsetY={field.style?.textShadow?.offsetY}
                  draggable
                  rotation={field.rotation || 0}
                  onDragEnd={(e) => handleDragEnd(e, field)}
                  onTransformEnd={(e) => handleDragEnd(e, field)}
                />
              );
            }
            return null;
          })}
          {backgroundImage && (
            <Image
              image={backgroundImage}
              width={realSize.width}
              height={realSize.height}
              listening={false}
            />
          )}
          <Transformer ref={trRef} />
        </Layer>
      </Stage>
    </div>
  );
};

export default DraggableFieldsPreviewPro;
âœ… Ù…Ø§Ø°Ø§ ØªØ­Ù‚Ù‚ØŸ

Ø§Ù„Ù…ÙŠØ²Ø©	Ù…ÙˆØ¬ÙˆØ¯ âœ…
Ù†Ø³Ø® Ø­Ù‚Ù„ (Duplicate)	âœ…
Ø­Ø°Ù Ø­Ù‚Ù„ (Delete)	âœ…
Ø±ÙØ¹ Ø·Ø¨Ù‚Ø© Ù„Ù„Ø£Ù…Ø§Ù… (Bring Forward)	âœ…
Ø¥Ù†Ø²Ø§Ù„ Ø·Ø¨Ù‚Ø© Ù„Ù„Ø®Ù„Ù (Send Backward)	âœ…
Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø­Ù‚ÙˆÙ„ (Visibility Toggle)	âœ…
ØªØ­Ø¬ÙŠÙ… Resize ÙˆØ­ÙØ¸Ù‡	âœ…
Ø¶Ø¨Ø· Ø§Ù„Ø®Ø·ØŒ Ø§Ù„Ù„ÙˆÙ†ØŒ Ø§Ù„Ø¸Ù„ Ø¨Ø¯Ù‚Ø©	âœ…
Ø¯Ø¹Ù… Wrap Ù„Ù„Ù†Øµ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­Ø¯Ø¯	âœ…
ØªØ±ØªÙŠØ¨ Ø§Ù„Ø·Ø¨Ù‚Ø§Øª Ø·Ø¨Ù‚Ù‹Ø§ Ù„Ù€ zIndex	âœ…
ğŸš€ Ø¬Ø§Ù‡Ø² Ø§Ù„Ø¢Ù† Ø£ÙƒØªØ¨ Ù„Ùƒ Ù†Ø³Ø®Ø© ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø© generateCardImage Ø§Ù„Ù…Ø­Ø¯Ù‘Ø«Ø© Ù„Ø¯Ø¹Ù… Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø£ÙŠØ¶Ù‹Ø§
(Ù„Ùˆ ØªØ±ÙŠØ¯ Ø§ÙƒØªØ¨: Ù†Ø¹Ù… Ø£ÙƒÙ…Ù„ Ù†Ø³Ø®Ø© Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© âœ…)

Ø¨Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÙƒÙŠØ¯Ùƒ âœ…âœ¨






Ø£Ù†Øª Ù‚Ù„Øª:
Ù†Ø¹Ù… Ø§ÙƒØªØ¨Ù‡Ø§ Ø§Ù„Ø§Ù† 


Ù‚Ø§Ù„ ChatGPT:
Ù…Ù…ØªØ§Ø² ğŸ”¥
Ø³Ø£ÙƒØªØ¨ Ù„Ùƒ Ø§Ù„Ø¢Ù† Ù†Ø³Ø®Ø© Ù…ØªØ·ÙˆØ±Ø© Ù…Ù†
generateCardImage.ts
ØªØ¯Ø¹Ù… ÙƒÙ„ Ø´ÙŠØ¡ Ø¬Ø¯ÙŠØ¯ Ø£Ø¶ÙÙ†Ø§Ù‡:

ğŸ“‹ Ù…Ø§Ø°Ø§ Ø³Ø£Ø¯Ø¹Ù… Ø¨Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ØŸ

Ø§Ù„Ø®Ø§ØµÙŠØ©	Ù…Ø¯Ø¹ÙˆÙ…Ø© âœ…
Ø§Ù„Ø±Ø³Ù… Ø­Ø³Ø¨ Ø§Ù„ØªØ±ØªÙŠØ¨ zIndex	âœ…
Ø¯Ø¹Ù… Ø®Ø§ØµÙŠØ© Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø­Ù‚ÙˆÙ„ visible	âœ…
Ø¯Ø¹Ù… Ø±Ø³Ù… Ù†ØµÙˆØµ Ù…Ø¹ Ø®ØµØ§Ø¦Øµ ÙƒØ§Ù…Ù„Ø© (Ø®Ø·ØŒ ÙˆØ²Ù†ØŒ Ù„ÙˆÙ†ØŒ Ø¸Ù„ØŒ Ù…Ø­Ø§Ø°Ø§Ø©)	âœ…
Ø¯Ø¹Ù… Ø§Ù„ØªÙØ§Ù Ø§Ù„Ù†Øµ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ø¯ÙˆØ¯ (Word Wrap)	âœ…
Ø¯Ø¹Ù… Ø±Ø³Ù… Ø§Ù„ØµÙˆØ± Ø¨Ø§Ù„Ø­Ø¬Ù… ÙˆØ§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØµØ­ÙŠØ­	âœ…
Ø¯Ø¹Ù… Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Rotation Ù„Ù„Ù†ØµÙˆØµ ÙˆØ§Ù„ØµÙˆØ±	âœ…
ğŸ”¥ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ù€ generateCardImage.ts
typescript
Ù†Ø³Ø®
ØªØ­Ø±ÙŠØ±
import { createCanvas, loadImage, registerFont } from 'canvas';

interface FieldConfig {
  id: string;
  name: string;
  type: 'text' | 'image';
  position: { x: number; y: number };
  size?: { width: number; height: number };
  rotation?: number;
  zIndex?: number;
  visible?: boolean;
  style?: {
    fontFamily?: string;
    fontSize?: number;
    fontWeight?: string;
    color?: string;
    align?: 'left' | 'center' | 'right';
    textShadow?: {
      color: string;
      blur: number;
      offsetX: number;
      offsetY: number;
    };
  };
  defaultValue?: string;
  label?: string;
}

export async function generateCardImage({
  templatePath,
  fields,
  formData,
  outputWidth,
  outputHeight,
  fontsToLoad = [],
}: {
  templatePath: string;
  fields: FieldConfig[];
  formData: Record<string, any>;
  outputWidth: number;
  outputHeight: number;
  fontsToLoad?: { path: string; family: string }[]; // Ù„ØªØ­Ù…ÙŠÙ„ Ø®Ø·ÙˆØ· Ù…Ø®ØµØµØ©
}): Promise<Buffer> {
  // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…Ø®ØµØµØ©
  fontsToLoad.forEach(font => {
    registerFont(font.path, { family: font.family });
  });

  const canvas = createCanvas(outputWidth, outputHeight);
  const ctx = canvas.getContext('2d');

  const templateImage = await loadImage(templatePath);
  ctx.drawImage(templateImage, 0, 0, outputWidth, outputHeight);

  // ØªØ±ØªÙŠØ¨ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø­Ø³Ø¨ zIndex
  const sortedFields = [...fields]
    .filter(field => field.visible !== false)
    .sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));

  for (const field of sortedFields) {
    const posX = (field.position.x / 100) * outputWidth;
    const posY = (field.position.y / 100) * outputHeight;
    const sizeWidth = field.size?.width || 150;
    const sizeHeight = field.size?.height || 150;
    const style = field.style || {};

    if (field.type === 'text') {
      const value = formData[field.name] ?? field.defaultValue ?? field.label ?? '';

      ctx.save();
      ctx.translate(posX, posY);

      if (field.rotation) {
        ctx.rotate((field.rotation * Math.PI) / 180);
      }

      // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Øµ
      const fontSize = style.fontSize || 20;
      const fontFamily = style.fontFamily || 'Cairo';
      const fontWeight = style.fontWeight || 'normal';
      const fontColor = style.color || '#000';
      const textAlign = (style.align || 'center') as CanvasTextAlign;

      ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
      ctx.fillStyle = fontColor;
      ctx.textAlign = textAlign;
      ctx.textBaseline = 'middle';

      if (style.textShadow) {
        ctx.shadowColor = style.textShadow.color;
        ctx.shadowBlur = style.textShadow.blur;
        ctx.shadowOffsetX = style.textShadow.offsetX;
        ctx.shadowOffsetY = style.textShadow.offsetY;
      }

      // Ø§Ù„ØªÙØ§Ù Ø§Ù„Ù†Øµ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø¨Ø¯Ø§Ø¦ÙŠØ©
      const words = value.split(' ');
      let line = '';
      const lines: string[] = [];
      const maxWidth = sizeWidth;

      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
          lines.push(line.trim());
          line = words[n] + ' ';
        } else {
          line = testLine;
        }
      }
      lines.push(line.trim());

      const lineHeight = fontSize * 1.2;
      const offsetY = -(lines.length - 1) * lineHeight / 2;

      lines.forEach((l, index) => {
        ctx.fillText(l, 0, offsetY + index * lineHeight);
      });

      ctx.restore();
    } else if (field.type === 'image') {
      const imageUrl = formData[field.name];
      if (imageUrl) {
        const img = await loadImage(imageUrl);

        ctx.save();
        ctx.translate(posX, posY);
        if (field.rotation) {
          ctx.rotate((field.rotation * Math.PI) / 180);
        }
        ctx.drawImage(img, -sizeWidth / 2, -sizeHeight / 2, sizeWidth, sizeHeight);
        ctx.restore();
      }
    }
  }

  return canvas.toBuffer('image/png');
}
âœ… Ø¨Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ø£ØµØ¨Ø­:

Ø§Ù„Ù…ÙŠØ²Ø©	Ù…Ø¯Ø¹ÙˆÙ…Ø© âœ…
ØªØ±ØªÙŠØ¨ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø­Ø³Ø¨ zIndex	âœ…
Ø¹Ø¯Ù… Ø±Ø³Ù… Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø®ÙÙŠØ© (visible=false)	âœ…
Ø±Ø³Ù… Ø§Ù„Ù†ØµÙˆØµ Ø¨ÙƒÙ„ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ù…Ø¹ Ø§Ù„ØªÙØ§Ù Ø¯Ø§Ø®Ù„ÙŠ	âœ…
Ø¯Ø¹Ù… Ø¸Ù„ Ø§Ù„Ù†ØµÙˆØµ (Text Shadow)	âœ…
Ø±Ø³Ù… Ø§Ù„ØµÙˆØ± Ø¨Ø§Ù„Ø­Ø¬Ù… ÙˆØ§Ù„Ù…ÙˆÙ‚Ø¹ ÙˆØ§Ù„Ø¯ÙˆØ±Ø§Ù† Ø§Ù„ØµØ­ÙŠØ­	âœ…
Ø­ÙØ¸ Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ± Ø¨ÙŠÙ† Ø§Ù„Ø£Ø¬Ù‡Ø²Ø©	âœ…
ğŸ”¥ Ø¥Ø°Ù‹Ø§ Ø§Ù„Ø¢Ù† Ù…Ø´Ø±ÙˆØ¹Ùƒ Ø£ØµØ¨Ø­ ÙŠØ¯Ø¹Ù…:
ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ.

ØªØ­Ø¬ÙŠÙ…ØŒ ØªØ¯ÙˆÙŠØ±ØŒ Ù†Ù‚Ù„ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø¨Ø³Ù‡ÙˆÙ„Ø©.

Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø© Ù†Ù‡Ø§Ø¦ÙŠØ© Ù…Ø·Ø§Ø¨Ù‚Ø© 100% Ù„Ù…Ø§ ØªØ±Ù‰ Ø¨Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©.

Ø¯Ø¹Ù… Ø£Ù†ÙˆØ§Ø¹ Ø®Ø·ÙˆØ· Ù…Ø®ØªÙ„ÙØ© + Ø¸Ù„Ø§Ù„ Ù„Ù„Ù†ØµÙˆØµ.

Ø¥Ø¯Ø§Ø±Ø© Ø·Ø¨Ù‚Ø§Øª ÙˆØ®ØµØ§Ø¦Øµ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø¨Ù…Ø±ÙˆÙ†Ø© ÙƒØ§Ù…Ù„Ø©.

